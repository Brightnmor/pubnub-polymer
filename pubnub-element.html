<link rel="import" href="bower_components/polymer/polymer.html"> 

<!--
Element that initializes PubNub.

### Example

    <core-pubnub publish_key="demo" subscribe_key="demo"></core-pubnub>

@element core-pubnub
@blurb Element providing encapsulation of the PubNub JS SDK.
@status alpha
@homepage 
-->
<polymer-element name="core-pubnub" hidden constructor="corePubNub" attributes="publish_key subscribe_key auth_key uuid cipher_key noleave keepalive secret_key ssl windwoing jsonp done pubnub">
  <script src="https://cdn.pubnub.com/pubnub.js"></script>

  <script>
    Polymer('core-pubnub', {
      /**
        * The `publish_key` attribute sets the publish_key that will be used when publishing messages to a channel.
        * **REQUIRED**
        *
        * @attribute publish_key
        * @type string
        * @default ''
        */
      publish_key: '',

      /**
        * The `subscribe_key` attribute sets the subscribe_key that will be used when subscribing to a channel.
        * **REQUIRED**
        *
        * @attribute subscribe_key
        * @type string
        * @default ''
        */
      subscribe_key: '',

      /**
        * The `auth_key` attribute sets the auth_key to be used for determining User-Level Access Manager permissions.
        * **OPTIONAL**
        *
        * @attribute auth_key 
        * @type string
        * @default undefined
        */
      
      /**
        * The `uuid` attribute sets the unique user id to be used to identify the client. By default a randomly generated uuid is created by the client.
        * **OPTIONAL**
        *
        * @attribute uuid
        * @type string
        * @default undefined
        */

      /**
        * The `cipher_key` attribute sets the cryptographic key to use for message level encryption with AES.
        * **OPTIONAL**
        *
        * @attribute cipher_key
        * @type string
        * @default undefined
        */

      /**
        * The `noleave` attribute, when set to true, explicitly disables presence leave events.
        * **OPTIONAL**
        *
        * @attribute noleave
        * @type boolean
        * @default false
        */

      /**
        * The `keepalive` attribute sets the interval betwween keepalive pings. Defaults to 60 seconds.
        * **OPTIONAL**
        *
        * @attribute keepalive 
        * @type number
        * @default 60
        */

      /**
        * The `secret_key` attribute sets the secret_key used only to sign Access Manager API messages.
        * **OPTIONAL**
        *
        * @attribute secret_key
        * @type string
        * @default undefined 
        */

      /**
        * The `ssl` attribute, when set to true, enables transport layer encryption with SSL/TLS. 
        * **OPTIONAL**
        *
        * @attribute ssl 
        * @type boolean
        * @default false
        */

      /**
        * The `windowing` sets the time interval in milliseconds that PubNub will use to optimize message delivery by bundling them into a single compressed payload.
        * **OPTIONAL**
        *
        * @attribute windowing
        * @type number
        * @default undefined
        */

      /**
       * The `jsonp` attribute, when set to true, explicitly enforces JSON(P) as the data transport method.
        * **OPTIONAL**
       *
       * @attribute jsonp
       * @type boolean
       * @default undefined
       */

      domReady: function() {
          var settings = {
            publish_key: this.publish_key,
            subscribe_key: this.subscribe_key,
            auth_key: this.auth_key,
            uuid: this.uuid,
            cipher_key: this.cipher_key,
            noleave: this.noleave,
            keepalive: this.keepalive,
            secret_key: this.secret_key,
            ssl: this.ssl,
            windowing: this.windowing,
            jsonp: this.jsonp
          }
          //console.log("CORE READY");
          this.pubnub = PUBNUB.init(settings);
          this.fire('ready', this.pubnub);
          this.done = true;
      },
      auth_keyChanged: function(oldValue, newValue) {
        this.pubnub.auth(newValue);
      }
    });
  </script>
</polymer-element>

<!--
Element that subscribes to PubNub channels.

Place it inside of a `<core-pubnub>` element.

All messages received while subscribed to the channel will be pushed into the messages list attribute.

### Example

    <core-pubnub publish_key="demo" subscribe_key="demo">
      <core-pubnub-subscribe channel="testChannel" messages={{messages}}>
      </core-pubnub-subscribe>
    </core-pubnub>


@element core-pubnub-subscribe
@blurb Element that subscribes to PubNub channels.
@status alpha
@homepage 
-->
<polymer-element name="core-pubnub-subscribe" hidden attributes="channel timetoken windowing heartbeat state messages presence subscribe pubnub done">
  <script>
    Polymer('core-pubnub-subscribe', {
      /**
        * The `channel` attribute specifies the channel to subscribe to. It is possible to specify multiple channels as an array.
        * **REQUIRED**
        *
        * @attribute channel
        * @type String or Array 
        * @default ''
        */
      channel: [],

      /**
        * The `timetoken` attribute specifies the timetoken from which to start returning any available cached messages. Message retrieval with timetoken is not guranteed and should only be considered a best-effort service.
        * **OPTIONAL**
        *
        * @attribute timetoken
        * @type Number 
        * @default undefined 
        */

      /**
        * The `windowing` attribute specifies the time interval in milliseconds that PubNub will use to optimize message delivery by bundling them into a single compressed payload. Setting a value of 1000 milliseconds will allow 100 messages in one second to be bundled and compressed for optimized delivery.
        * **OPTIONAL**
        *
        * @attribute windowing
        * @type Number 
        * @default 10
        */
      
      /**
        * The `heartbeat` attribute defines the period in seconds after which the client should be disconnected due to in-activity. The default is `320` seconds. For mobile devices operating in environments that commonly experience highly variable network connectivity, setting a higher value for heartbeat would prevent the client from experiencing frequent leave/join events.
        * **OPTIONAL**
        *
        * @attribute heartbeat
        * @type Number 
        * @default 320 
        */

      /**
        * The `state` attribute is a JSON object of key/value pairs with supported data-types of int, float and string. Nesting of key/values is not permitted and key names beginning with prefix "pn" are reserved.
        * If `state` is undefined, the current state for the specified `uuid` will be returned. If a specified key already exists for the `uuid` it will be over-written with the new value. Key values can be deleted by setting the particular value to "null". 
        * All `state` data for a user is deleted once the associated uuid leaves the channel.
        * **OPTIONAL**
        *
        * @attribute state 
        * @type Object
        * @default undefined
        */

      subscribe: true,
      domReady: function() {
        var self = this;
        this.sub = function() {
          self.messages = [];
          self.presence = [];
          self.pubnub.subscribe({
            channel: self.channel,
            timetoken: self.timetoken,
            connect: function (m) {
              // Fire Connect Event.
              // console.log("connect");
              self.fire('connect', m);
              self.fire('ready', self.pubnub);
              self.done = true;
            },
            disconnect: function(m) {
              // Fire Disconnect Event.
              // console.log("disconnect");
              self.fire('disconnect', m);
            },
            error: function(m) {
              // Fire Error Event.
              // console.log("error");
              self.fire('error', m);
            },
            callback: function(m) {
              // Fire Message Event.
              // console.log("message");
              // console.log(m);
              self.messages.push(m);
              //console.log(messages);
              self.fire('callback', m);
            },
            presence: function(m) {
              // Fire Presence Event.
              // console.log("presence");
              // console.log(m);
              self.presence.push(m);
              self.fire('presence', m);
            },
            reconnect: function(m) {
              // Fire Reconnect Event.
              // console.log("reconnect");
              self.fire('reconnect', m);
            },
            restore: function(m) {
              // Fire Restore Event.
              // console.log("restored");
              self.fire('restore', m);
            },
            windowing: self.windowing,
            heartbeat: self.heartbeat,
            state: self.state
          });
        };
        var onReady = function(e) {
          self.pubnub = e.detail;
          if (self.subscribe) {
            self.sub();
          }
          self.parentNode.removeEventListener('ready', onReady);
        };
        if (this.parentNode.done) {
          onReady({detail : this.parentNode.pubnub});
        }
        else {
          this.parentNode.addEventListener('ready', onReady);
        }
      },
      subscribeChanged: function(oldValue, newValue) {
        if (newValue) {
          this.sub();
        }
        else {
          this.pubnub.unsubscribe({
            channel: this.channel    
          });
        }
      },
      detached: function() {
        if (subscribe) {
          this.pubnub.unsubscribe({
            channel: this.channel
          });
        }
      }
    });
  </script>

</polymer-element>

<polymer-element name="core-pubnub-publish" hidden attributes="channel message publish_key pubnub done">
  <script>
    Polymer('core-pubnub-publish', {
      message: {},
      domReady: function() {
        var self = this;
        var onReady = function(e) {
          // console.log(e);
          // console.log("PUBLISHING TIME");
          self.pubnub = e.detail;
          var ready = function() {
            self.fire('ready', self.pubnub);
            self.done = true;
          };
          self.pubnub.publish({
            channel: self.channel,
            message: self.message,
            publish_key: self.publish_key,
            callback: function(m) {
              self.fire('callback', m);
              ready();
            },
            error: function(m) {
              self.fire('error', m);
              ready();
            }
          });
          self.parentNode.removeEventListener('ready', onReady);
        }
        if (this.parentNode.done) {
          onReady({detail: this.parentNode.pubnub});
        }
        else {
          this.parentNode.addEventListener('ready', onReady);
        }
      },
      publish: function() {
        this.pubnub.publish({
          channel: this.channel,
          message: this.message,
          publish_key: this.publish_key,
          callback: function(m) {
            self.fire('callback', m);
            ready();
          },
          error: function(m) {
            self.fire('error', m);
            ready();
          }
        });
     },
    });
  </script>
</polymer-element>

<polymer-element name="core-pubnub-history" hidden attributes="channel count end reverse start history pubnub done">
  <script>
    Polymer('core-pubnub-history', {
      count: 100,
      domReady: function() {
        var self = this;
        var onReady = function(e) {
          // console.log("CALL ME MAYBE");
          self.pubnub = e.detail;
          var ready = function() {
            self.fire('ready', self.pubnub);
            self.done = true;
          };
          self.pubnub.history({
            channel: self.channel,
            count: self.count,
            end: self.end,
            reverse: self.reverse,
            start: self.start,
            callback: function(m) {
              self.history = m;
              // console.log("HISTORY IS IN THE MAKING!");
              // console.log(m);
              self.fire('callback', m);
              ready();
            },
            error: function(m) {
              self.fire('error', m);
              ready();
            }
          });
          self.parentNode.removeEventListener('ready', onReady);
        }
        if (this.parentNode.done) {
          onReady({detail: this.parentNode.pubnub});
        }
        else {
          this.parentNode.addEventListener('ready', onReady);
        }
      }
    });
  </script>
</polymer-element>

<polymer-element name="core-pubnub-here-now" hidden attributes="channel state uuids presence pubnub done">
  <script>
    Polymer('core-pubnub-here-now', {
      state: false,
      uuids: true,
      presence: [], 
      domReady: function() {
        var self = this;
        var onReady = function(e) {
          self.pubnub = e.detail;
          var ready = function() {
            self.fire('ready', self.pubnub);
            self.done = true;
          };
          self.pubnub.here_now({
            channel: self.channel,
            state: self.state,
            uuids: self.uuids,
            error: function(m) {
              // console.log('error');
              self.fire('error', m);
            },
            callback: function(m) {
              // console.log('callback');
              self.presence = m.uuids;
              // console.log(m);
              self.fire('callback', m);
            }
          });
          self.parentNode.removeEventListener('ready', onReady);
        }
        if (this.parentNode.done) {
          onReady({detail: this.parentNode.pubnub});
        }
        else {
          this.parentNode.addEventListener('ready', onReady);
        }
      }
    });
  </script>
</polymer-element>

<polymer-element name="core-pubnub-where-now" hidden attributes="uuid presence pubnub done">
  <script>
    Polymer('core-pubnub-where-now', {
        presence: [],      
        domReady: function() {
        var self = this;
        var onReady = function(e) {
          self.pubnub = e.detail;
          var ready = function() {
            self.fire('ready', self.pubnub);
            self.done = true;
          };
          self.pubnub.where_now({
            uuid: self.uuid,
            callback: function(m) {
              // console.log(m);
              self.presence = m.channels;
              self.fire('callback', m);
              ready();
            },
            error: function(m) {
              // console.log(m);
              self.fire('error', m);
              ready();
            }
          });
          self.parentNode.removeEventListener('ready', onReady);
        }
        if (this.parentNode.done) {
          onReady({detail: this.parentNode.pubnub});
        }
        else {
          this.parentNode.addEventListener('ready', onReady);
        }
      }
    });
  </script>
</polymer-element>

<polymer-element name="core-pubnub-replay" hidden attributes="source destination end limit reverse start stop pubnub done">
  <script>
    Polymer('core-pubnub-replay', {
      domReady: function() {
        var self = this;
        var onReady = function(e) {
          self.pubnub = e.detail;
          var ready = function() {
            self.fire('ready', self.pubnub);
            self.done = true;
          };
          pubnub.replay({
            source: self.source,
            destination: self.destination,
            end: self.end,
            limit: self.limit,
            reverse: self.reverse,
            start: self.start,
            stop: self.stop,
            callback: function(m) {
              // console.log("AOSIDJIOAJDOIASJDIOAJSIDJAOJSDIAJDSOJAISDJOAJDISADJSIDAOJ");
              // console.log(m);
              self.fire('callback', m);
              ready();
            }
          });
          self.parentNode.removeEventListener('ready', onReady);
        }
        if (this.parentNode.done) {
          onReady({detail: this.parentNode.pubnub});
        }
        else {
          this.parentNode.addEventListener('ready', onReady);
        }
      }
    });
  </script>
</polymer-element>
